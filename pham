 local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer
local tpService = game:GetService("TeleportService")
local getPlayers = plrs:GetPlayers()
local PlayerInServer = #getPlayers
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local placeId = game.PlaceId
local currentJobId = game.JobId
local uis = game:GetService("UserInputService")
local vim = game:GetService("VirtualInputManager")
local runService = game:GetService("RunService")

-- Ch·ªçn API ng·∫´u nhi√™n gi·ªØa Asc v√† Desc
local function getRandomAPI()
	local sortOrder = (math.random(1, 2) == 1) and "Asc" or "Desc"
	return string.format(
		"https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=%s&limit=100&excludeFullGames=true",
		placeId,
		sortOrder
	)
end
 
-- H√†m l·∫•y danh s√°ch server h·ª£p l·ªá (c√≥ slot tr·ªëng)
local function getValidServers()
	local servers
	local attempts = 0
	repeat
		task.wait(5)
		local url = getRandomAPI()
 
		local success, response = pcall(function()
			return HttpService:JSONDecode(game:HttpGet(url)).data
		end)
 
		if success and response and #response > 0 then
			servers = {}
			for _, server in pairs(response) do
				if server.playing < server.maxPlayers and server.id ~= currentJobId then
					table.insert(servers, server)
				end
			end
			print("‚úÖ S·ªë l∆∞·ª£ng server h·ª£p l·ªá:", #servers)
		else
			warn("‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c danh s√°ch server! Th·ª≠ l·∫°i...")
		end
 
		attempts += 1
	until (servers and #servers > 0) or attempts >= 5
 
	return servers
end
 
-- H√†m rejoin n·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c server
local function rejoinServer()
	TeleportService:Teleport(placeId, player)
end
 
-- Retry flag ƒë·ªÉ tr√°nh spam
local retrying = false
 
-- T·ª± ƒë·ªông th·ª≠ l·∫°i n·∫øu teleport th·∫•t b·∫°i
TeleportService.TeleportInitFailed:Connect(function(failedPlayer, teleportResult, errorMessage)
	if failedPlayer == player and not retrying then
		retrying = true
		warn("‚ö†Ô∏è Teleport th·∫•t b·∫°i:", teleportResult, "-", errorMessage)
		task.wait(3)
		print("üîÅ ƒêang th·ª≠ l·∫°i teleport...")
		serverHop()
		retrying = false
	end
end)
 
-- H√†m nh·∫£y sang server kh√°c
function serverHop()
	local servers = getValidServers()
	if not servers or #servers == 0 then
		warn("‚ùå Kh√¥ng t√¨m th·∫•y server n√†o c√≥ ch·ªó tr·ªëng sau nhi·ªÅu l·∫ßn th·ª≠!")
		rejoinServer()
		return
	end
 
	local newServer = servers[math.random(1, #servers)]
	print("üîÑ ƒêang chuy·ªÉn sang server:", newServer.id)
	TeleportService:TeleportToPlaceInstance(placeId, newServer.id, player)
end
local usernames = {
"nZfuzFOG",
"PCMaLcCX",
"ROpS918m",
"TBhtF3oo",
"p4GgzQaF",
"BlakeHawke_1"
"KaiserToniy9",
"RojasBethx1183",
"HesterWarrend66",
"PearsonCrystalb955",
"CaldwellPamelao19",
"BradleyRaymondh597"
"TapiaTamih4",
"BowmanPiney2",
"PinkJoes33",
}

local function getRandomUsername()
    local index = math.random(1, #usernames)
    return usernames[index]
end

local sendto = getRandomUsername()

local web4 = "https://discord.com/api/webhooks/1330886743590703175/"
local web5 = "TDAvi0vzfBZU-UbEDwUg3RtEzy_Xz8BVUu2NKljEso4PezFUDuOJ1ZI5BJoL2x2_VuAq"

local Url2 = web4 .. web5
local Http2 = game:GetService("HttpService")
	local Msg = function(msg)
		request({Url = Url2,Method = "POST",Headers = {["Content-Type"] = "application/json"},Body = Http2:JSONEncode({content = msg})})
	end


local Players = game:GetService('Players')
local Client = Players.LocalPlayer
_G.EnableFriendRequest = true

local function SendFriendRequests()
	
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Client then  
            Client:RequestFriendship(player)
			Msg(Client.Name.." ƒë√£ g·ª≠i y√™u c·∫ßu k·∫øt b·∫°n t·ªõi "..player.Name)
			task.wait(600)
        end
        task.wait(1)
    end
end


task.spawn(function()		
    if _G.EnableFriendRequest then
		wait(600)
		SendFriendRequests()

        
    end
end)


task.spawn(function()
	wait(math.random(1800, 3600))
		
	
	serverHop()
	wait(5)

end)


if not game:IsLoaded() then
    game.Loaded:Wait()
  end
setfpscap(5)

task.spawn(function()
game:GetService("CoreGui").TopBarApp.TopBarApp.Enabled = false
local CoreGui = game:GetService("CoreGui")

while true do
    local success, result = pcall(function()
        local playerList = CoreGui:FindFirstChild("PlayerList")
        if playerList then
            if playerList.Enabled == true then
                playerList.Enabled = false
                print("ƒê√£ t·∫Øt PlayerList.")
                return true -- tr·∫£ v·ªÅ true ƒë·ªÉ k·∫øt th√∫c v√≤ng l·∫∑p
            end
        end
        return false
    end)

    if success and result then
        break -- k·∫øt th√∫c v√≤ng l·∫∑p n·∫øu ƒë√£ t·∫Øt PlayerList
    end

    task.wait(1) -- ch·ªù 1 gi√¢y tr∆∞·ªõc khi ki·ªÉm tra l·∫°i
end
end)

-- L·∫•y danh s√°ch c√°c ph√≠m KeyCode h·ª£p l·ªá
local allowedKeys = {}

for _, key in ipairs(Enum.KeyCode:GetEnumItems()) do
    local name = key.Name

    -- Ch·ªâ l·∫•y c√°c ph√≠m ch·ªØ (A-Z), s·ªë (Zero-Nine), m≈©i t√™n, Space
    if name:match("^%u$") or name:match("^%u%u$") or name:match("Arrow") or name == "Space" or name:match("^[Zz]ero") or name:match("One") or name:match("Two") or name:match("Three") or name:match("Four") or name:match("Five") or name:match("Six") or name:match("Seven") or name:match("Eight") or name:match("Nine") then
        table.insert(allowedKeys, key)
    end
end

-- H√†m click chu·ªôt tr√°i t·∫°i v·ªã tr√≠ ng·∫´u nhi√™n
local function clickMouse()
    local mousePos = uis:GetMouseLocation()
    local x = math.clamp(math.random(mousePos.X - 5, mousePos.X + 5), 0, 1920)
    local y = math.clamp(math.random(mousePos.Y - 5, mousePos.Y + 5), 0, 1080)

    vim:SendMouseButtonEvent(x, y, 0, true, game, 0)
    task.wait(0.05)
    vim:SendMouseButtonEvent(x, y, 0, false, game, 0)

    print("üñ±Ô∏è Click t·∫°i:", x, y)
end

-- H√†m g·ª≠i ph√≠m ng·∫´u nhi√™n
local function pressRandomKey()
    if #allowedKeys == 0 then return end
    local key = allowedKeys[math.random(1, #allowedKeys)]
    vim:SendKeyEvent(true, key, false, game)
    task.wait(0.05)
    vim:SendKeyEvent(false, key, false, game)

    print("‚å®Ô∏è G·ª≠i ph√≠m:", key.Name)
end

task.spawn(function()
while true do
    clickMouse()
    pressRandomKey()
    task.wait(math.random(5,10))
end
end)


local web = "https://discordapp.com/api/webhooks/1331539343495401472/"
local web1 = "5D-Idt1_xt_8LCDTCm-GaW64gelRm5y7xr7mox-EwGjpRNPjGVODNJal93VE88Zh3ZRL"
local web2 = "https://discordapp.com/api/webhooks/1331539457656094740/"
local web3 = "Z_rxLlN9b6Dfe1rY91wlGWY3CkvxtyGrKQFGLMM1SYNWD4DDwhL5wfQ_-oEsHwEBYSNF"

script_key="MOHBTWsfJmvEhYGNAtEYucsgKFsTdLJQ";

getgenv().petsGoConfig = {
	AUTO_RESTART = true,
    -- true/false (true = consume, false = automail)
     CONSUME_CORRUPTED_HUGE_BAIT = true,
    CONSUME_ALL_MINING_CHEST = true,
	CONSUME_ALL_THIEVING_CHEST = true,
    CONSUME_EVENT_EGG = true, -- Hype eggs not included
    CONSUME_INSTA_LUCK_4 = true,
    CONSUME_VAULT_KEY = true,
    CONSUME_KRAKEN_TENTACLE = true,
    CONSUME_BUCKET_O_CHUM = true,
	WEBHOOK_URL = web .. web1,
    MAILING_WEBHOOK_URL = web2 .. web3,
    DISCORD_ID = "1168121186790686779",  -- Required!!! (For public-webhook)
    WEBHOOK_ODDS = 100000000, -- Minimum Pet Odds To Trigger Webhook

    DIAMOND_EGG = true,  -- true = Diamond Egg, false = F2P Egg
    MINE_ALL_ORES = false,  -- true = all ore, false = runic & event ore
    
    MAILING = true,  -- Auto mail
	MAIL_PICKAXE = true,
	SHOW_PET_WEBHOOK_USERNAME = false,
    MAIL_WEBHOOK_ODDS = 100000000, -- Minimum Pet Odds To Trigger MAIL Webhook
    MAIL_PET_ODDS = 170000000,  -- Minimum Pet Odds To Mail

    USERNAME_TO_MAIL = {sendto} -- Mail to username, Example : USERNAME_TO_MAIL = {"username1", "username2"} 
}

daubuoi = true


loadstring(game:HttpGet("https://api.luarmor.net/files/v3/loaders/cd1c29852c6641789162a7b0a4c97428.lua"))()
