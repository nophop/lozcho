print("load thanh cong extrabgsi")
task.wait(20)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalDataService = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local player = Players.LocalPlayer

-- Danh s√°ch c√°c lo·∫°i thu·ªëc
local listPotions = {
    { Name = "Lucky", MinAmount = 10 },
    { Name = "Speed", MinAmount = 10 },
    { Name = "Mythic", MinAmount = 10 },
    { Name = "Coins", MinAmount = 10 },
    { Name = "Tickets", MinAmount = 10 }
}
-- Danh s√°ch c√°c lo·∫°i elixir
local listPotionsUse = {
    { Name = "Infinity Elixir", MinAmount = 10 }
}

-- Bi·∫øn ƒë·ªÉ qu·∫£n l√Ω tr·∫°ng th√°i lu·ªìng autorolldice
local isRolling = false
local rollTask = nil
local mindices = 100

-- H√†m ƒë·ªãnh d·∫°ng s·ªë v·ªõi d·∫•u ph·∫©y (v√≠ d·ª•: 1456448 -> 1,456,448)
local function formatNumber(number)
    if not number then return "0" end
    local formatted = tostring(number)
    local result = ""
    local count = 0
    for i = #formatted, 1, -1 do
        result = formatted:sub(i, i) .. result
        count = count + 1
        if count % 3 == 0 and i > 1 then
            result = "," .. result
        end
    end
    return result
end

-- H√†m ki·ªÉm tra Gems, Coins, Tickets m·ªói 5 ph√∫t v√† rejoin n·∫øu kh√¥ng thay ƒë·ªïi ho·∫∑c kh√¥ng x√°c ƒë·ªãnh
local function checkCurrencies()
    local playerData = LocalDataService:Get()
    local previousGems = playerData.Gems
    local previousCoins = playerData.Coins
    local previousTickets = playerData.Tickets
    local previousSeashells = playerData.Seashells
    task.wait(120)
    while true do
        playerData = LocalDataService:Get()
        local currentGems = playerData.Gems
        local currentCoins = playerData.Coins
        local currentTickets = playerData.Tickets
        local currentSeashells = playerData.Seashells
        print("Gems: " .. formatNumber(currentGems) .. ", Coins: " .. formatNumber(currentCoins) .. ", Tickets: " .. formatNumber(currentTickets) .. ", Seashells: " .. formatNumber(currentSeashells))
        if currentGems == previousGems and currentCoins == previousCoins and currentTickets == previousTickets and  currentSeashells == previousSeashells then
            print("Kh√¥ng c√≥ thay ƒë·ªïi trong Gems, Coins, Tickets. Rejoining server...")
            rejoinServer()
            task.wait(5)
        end
        previousGems = currentGems
        previousCoins = currentCoins
        previousTickets = currentTickets
        previousSeashells = currentSeashells
        task.wait(180) -- Ch·ªù 5 ph√∫t (300 gi√¢y)
    end
end

-- H√†m g·ª≠i y√™u c·∫ßu n√¢ng c·∫•p
local function upgradeMastery(category)
    local success, result = pcall(function()
        local args = {
            [1] = "UpgradeMastery",
            [2] = category
        }
        local remote = ReplicatedStorage
            :WaitForChild("Shared")
            :WaitForChild("Framework")
            :WaitForChild("Network")
            :WaitForChild("Remote")
            :WaitForChild("RemoteEvent")
        remote:FireServer(unpack(args))
    end)
    if not success then
        warn("Failed to upgrade " .. category .. ": " .. result)
    end
end

-- H√†m ch·∫°y v√≤ng l·∫∑p n√¢ng c·∫•p cho Shops
local function autoUpgradeShops()
    wait(60)
    while true do
        local success, playerData = pcall(function()
            return LocalDataService:Get()
        end)
        local shopsLevel = 0
        if success and playerData and playerData.MasteryLevels then
            shopsLevel = playerData.MasteryLevels.Shops or 0
        else
            warn("Could not retrieve Shops level, treating as Level 0...")
        end
        if shopsLevel >= 11 then
            print("Shops reached Level 10, stopping Shops auto-upgrade.")
            break
        else
            print("Shops Level: " .. shopsLevel .. ", upgrading Shops...")
            upgradeMastery("Shops")
        end
        task.wait(110)
    end
end

-- H√†m ch·∫°y v√≤ng l·∫∑p n√¢ng c·∫•p cho Minigames
local function autoUpgradeMinigames()
    wait(60)
    while true do
        local success, playerData = pcall(function()
            return LocalDataService:Get()
        end)
        local minigamesLevel = 0
        if success and playerData and playerData.MasteryLevels then
            minigamesLevel = playerData.MasteryLevels.Minigames or 0
        else
            warn("Could not retrieve Minigames level, treating as Level 0...")
        end
        if minigamesLevel >= 8 then
            print("Minigames reached Level 8, stopping Minigames auto-upgrade.")
            break
        else
            print("Minigames Level: " .. minigamesLevel .. ", upgrading Minigames...")
            upgradeMastery("Minigames")
        end
        task.wait(120)
    end
end

-- H√†m ch·∫°y v√≤ng l·∫∑p n√¢ng c·∫•p cho Pets v√† Buffs
local function autoUpgradePetsAndBuffs()
    wait(100)
    while true do
        local success, playerData = pcall(function()
            return LocalDataService:Get()
        end)
        local petsLevel = 0
        local buffsLevel = 0
        if success and playerData and playerData.MasteryLevels then
            petsLevel = playerData.MasteryLevels.Pets or 0
            buffsLevel = playerData.MasteryLevels.Buffs or 0
        else
            warn("Could not retrieve Pets or Buffs level, treating as Level 0...")
        end

        -- Giai ƒëo·∫°n 1: N√¢ng c·∫•p c·∫£ Pets v√† Buffs ƒë·∫øn khi Buffs ƒë·∫°t c·∫•p 7
        if buffsLevel < 7 and petsLevel < 15 then
            print("Buffs Level: " .. buffsLevel .. ", upgrading Buffs...")
            upgradeMastery("Buffs")
            print("Pets Level: " .. petsLevel .. ", upgrading Pets...")
            upgradeMastery("Pets")
        -- Giai ƒëo·∫°n 2: Buffs ƒë·∫°t c·∫•p 7, ∆∞u ti√™n n√¢ng c·∫•p Pets ƒë·∫øn c·∫•p 15
        elseif buffsLevel >= 7 and petsLevel < 15 then
            print("Buffs reached Level 7, prioritizing Pets...")
            print("Pets Level: " .. petsLevel .. ", upgrading Pets...")
            upgradeMastery("Pets")
        -- Giai ƒëo·∫°n 3: Pets ƒë·∫°t c·∫•p 15, ti·∫øp t·ª•c n√¢ng c·∫•p Buffs ƒë·∫øn c·∫•p 14
        elseif petsLevel >= 15 and buffsLevel < 21 then
            print("Pets reached Level 15, resuming Buffs upgrade...")
            print("Buffs Level: " .. buffsLevel .. ", upgrading Buffs...")
            upgradeMastery("Pets")
            task.wait(1)
            upgradeMastery("Buffs")
        -- Giai ƒëo·∫°n 4: Pets ƒë·∫°t c·∫•p 15 v√† Buffs ƒë·∫°t c·∫•p 14, d·ª´ng l·∫°i
        elseif petsLevel >= 17 and buffsLevel >= 21 then
            print("Pets Level 15 and Buffs Level 14 achieved, stopping upgrades...")
            break
        end
        task.wait(100)
    end
end

-- H√†m trang b·ªã pet t·ªët nh·∫•t
local function equipbestpet()
    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("EquipBestPets")
end

-- H√†m ch·∫ø t·∫°o Potion
local function craftPotion(potionName, level)
    local success, result = pcall(function()
        local args = {
            [1] = "CraftPotion",
            [2] = potionName,
            [3] = level,
            [4] = false
        }
        local remote = ReplicatedStorage
            :WaitForChild("Shared")
            :WaitForChild("Framework")
            :WaitForChild("Network")
            :WaitForChild("Remote")
            :WaitForChild("RemoteEvent")
        remote:FireServer(unpack(args))
    end)
    if success then
        print("ƒê√£ ch·∫ø t·∫°o " .. potionName .. " c·∫•p " .. level)
    else
        warn("L·ªói khi ch·∫ø t·∫°o " .. potionName .. " c·∫•p " .. level .. ": " .. result)
    end
end

-- H√†m ki·ªÉm tra v√† ch·∫ø t·∫°o Potions
local function autoCraftPotions()
    task.wait(180) -- Ch·ªù 60 gi√¢y tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu
    while true do
        local success, playerData = pcall(function()
            return LocalDataService:Get()
        end)
        if success and playerData and playerData.Potions then
            for _, potionConfig in ipairs(listPotions) do
                local potionName = potionConfig.Name
                local minAmount = potionConfig.MinAmount
                local level5Count = 0

                -- Ki·ªÉm tra s·ªë l∆∞·ª£ng Potion c·∫•p 5
                for _, potion in pairs(playerData.Potions) do
                    if potion.Name == potionName and potion.Level == 5 then
                        level5Count = potion.Amount or 0
                        break
                    end
                end

                print("Potion " .. potionName .. " c·∫•p 5: " .. level5Count .. " (Y√™u c·∫ßu t·ªëi thi·ªÉu: " .. minAmount .. ")")
                if level5Count < minAmount then
                    print("S·ªë l∆∞·ª£ng Potion " .. potionName .. " c·∫•p 5 d∆∞·ªõi m·ª©c t·ªëi thi·ªÉu, b·∫Øt ƒë·∫ßu ch·∫ø t·∫°o...")

                    -- Ch·∫ø t·∫°o t·ª´ c·∫•p 4 l√™n c·∫•p 5 (n·∫øu c√≥ ƒë·ªß)
                    local level4Count = 0
                    for _, potion in pairs(playerData.Potions) do
                        if potion.Name == potionName and potion.Level == 4 then
                            level4Count = potion.Amount or 0
                            break
                        end
                    end
                    while level4Count >= 8 do
                        craftPotion(potionName, 5)
                        level4Count = level4Count - 8
                        task.wait(1) -- Ch·ªù 1 gi√¢y gi·ªØa c√°c l·∫ßn ch·∫ø t·∫°o
                    end

                    -- Ch·∫ø t·∫°o t·ª´ c·∫•p 3 l√™n c·∫•p 4 (n·∫øu c√≥ ƒë·ªß)
                    local level3Count = 0
                    for _, potion in pairs(playerData.Potions) do
                        if potion.Name == potionName and potion.Level == 3 then
                            level3Count = potion.Amount or 0
                            break
                        end
                    end
                    while level3Count >= 6 do
                        craftPotion(potionName, 4)
                        level3Count = level3Count - 6
                        task.wait(1)
                    end

                    -- Ch·∫ø t·∫°o t·ª´ c·∫•p 2 l√™n c·∫•p 3 (n·∫øu c√≥ ƒë·ªß)
                    local level2Count = 0
                    for _, potion in pairs(playerData.Potions) do
                        if potion.Name == potionName and potion.Level == 2 then
                            level2Count = potion.Amount or 0
                            break
                        end
                    end
                    while level2Count >= 4 do
                        craftPotion(potionName, 3)
                        level2Count = level2Count - 4
                        task.wait(1)
                    end

                    -- Ch·∫ø t·∫°o t·ª´ c·∫•p 1 l√™n c·∫•p 2 (n·∫øu c√≥ ƒë·ªß)
                    local level1Count = 0
                    for _, potion in pairs(playerData.Potions) do
                        if potion.Name == potionName and potion.Level == 1 then
                            level1Count = potion.Amount or 0
                            break
                        end
                    end
                    while level1Count >= 4 do
                        craftPotion(potionName, 2)
                        level1Count = level1Count - 4
                        task.wait(1)
                    end
                end
            end
        else
            warn("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu Potions, th·ª≠ l·∫°i sau...")
        end
        task.wait(300) -- Ki·ªÉm tra l·∫°i sau 5 ph√∫t
    end
end

-- H√†m s·ª≠ d·ª•ng Potion
local function usePotion(potionName)
    local success, result = pcall(function()
        local args = {
            [1] = "UsePotion",
            [2] = potionName,
            [3] = 1
        }
        local remote = ReplicatedStorage
            :WaitForChild("Shared")
            :WaitForChild("Framework")
            :WaitForChild("Network")
            :WaitForChild("Remote")
            :WaitForChild("RemoteEvent")
        remote:FireServer(unpack(args))
    end)
    if success then
        print("ƒê√£ s·ª≠ d·ª•ng 1 " .. potionName)
    else
        warn("L·ªói khi s·ª≠ d·ª•ng " .. potionName .. ": " .. result)
    end
end

-- H√†m ki·ªÉm tra v√† s·ª≠ d·ª•ng Potions t·ª´ listPotionsUse
local function autoUsePotions()
    while true do
        local success, playerData = pcall(function()
            return LocalDataService:Get()
        end)
        if success and playerData and playerData.Potions then
            for _, potionConfig in ipairs(listPotionsUse) do
                local potionName = potionConfig.Name
                local minAmount = potionConfig.MinAmount
                local potionCount = 0

                -- Ki·ªÉm tra s·ªë l∆∞·ª£ng Potion c·∫•p 1
                for _, potion in pairs(playerData.Potions) do
                    if potion.Name == potionName and potion.Level == 1 then
                        potionCount = potion.Amount or 0
                        break
                    end
                end

                print("Potion " .. potionName .. " c·∫•p 1: " .. potionCount .. " (Y√™u c·∫ßu t·ªëi thi·ªÉu: " .. minAmount .. ")")
                if potionCount > minAmount then
                    print("S·ªë l∆∞·ª£ng Potion " .. potionName .. " c·∫•p 1 l·ªõn h∆°n m·ª©c t·ªëi thi·ªÉu, b·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng...")
                    while potionCount > minAmount do
                        usePotion(potionName)
                        potionCount = potionCount - 1
                        task.wait(1) -- Ch·ªù 1 gi√¢y gi·ªØa c√°c l·∫ßn s·ª≠ d·ª•ng
                    end
                end
            end
        else
            warn("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu Potions, th·ª≠ l·∫°i sau...")
        end
        task.wait(300) -- Ki·ªÉm tra l·∫°i sau 5 ph√∫t
    end
end

local RemoteFolder = ReplicatedStorage
    :WaitForChild("Shared")
    :WaitForChild("Framework")
    :WaitForChild("Network")
    :WaitForChild("Remote")

local RemoteFunction = RemoteFolder:WaitForChild("RemoteFunction")
local RemoteEvent = RemoteFolder:WaitForChild("RemoteEvent")

-- H√†m t·ª± ƒë·ªông tung x√∫c x·∫Øc
local function autorolldice()
    isRolling = true
    print("B·∫Øt ƒë·∫ßu autorolldice...")
    while isRolling do
        local success, playerData = pcall(function()
            return LocalDataService:Get()
        end)
        if success and playerData and playerData.Powerups then
            local diceCount = playerData.Powerups.Dice or 0
            if diceCount <= mindices then
                print("S·ªë l∆∞·ª£ng Dice <= 100, d·ª´ng autorolldice...")
                isRolling = false
                rollTask = nil
                break
            end
        else
            warn("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu Powerups trong autorolldice, ti·∫øp t·ª•c th·ª≠...")
        end

        local success = pcall(function()
            RemoteFunction:InvokeServer("RollDice", "Dice")
        end)

        if not success then
            pcall(function()
                RemoteFunction:InvokeServer("RollDice", "Giant Dice")
            end)
        end

        task.wait(1)

        RemoteEvent:FireServer("ClaimTile")

        task.wait(1)
    end
end

-- H√†m ki·ªÉm tra s·ªë l∆∞·ª£ng Dice v√† qu·∫£n l√Ω lu·ªìng autorolldice
local function checkDiceAndRoll()
    wait(5) -- Ch·ªù 60 gi√¢y tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu
    while true do
        local success, playerData = pcall(function()
            return LocalDataService:Get()
        end)
        if success and playerData and playerData.Powerups then
            local diceCount = playerData.Powerups.Dice or 0
            print("S·ªë l∆∞·ª£ng Dice: " .. diceCount)
            if diceCount > mindices and not isRolling then
                print("S·ªë l∆∞·ª£ng Dice > 100, k√≠ch ho·∫°t autorolldice...")
                rollTask = task.spawn(autorolldice)
            elseif diceCount <= mindices and isRolling then
                print("S·ªë l∆∞·ª£ng Dice <= 100, y√™u c·∫ßu d·ª´ng autorolldice...")
                isRolling = false -- D·ª´ng lu·ªìng b·∫±ng c√°ch ƒë·∫∑t isRolling th√†nh false
                rollTask = nil
            end
        else
            warn("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu Powerups, th·ª≠ l·∫°i sau...")
        end
        task.wait(300) -- Ki·ªÉm tra l·∫°i sau 5 ph√∫t
    end
end

-- H√†m g·ª≠i c√†i ƒë·∫∑t game
local function setSetting(settingName, value)
    local args = {
        [1] = "SetSetting",
        [2] = settingName,
        [3] = value
    }
    ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent:FireServer(unpack(args))
    task.wait(1)
end

-- H√†m equip pet
local function equipPet(idpet)
    local args = {
        "EquipPet",
        idpet
    }
    local success = pcall(function()
        RemoteEvent:FireServer(unpack(args))
    end)
    if not success then
        warn("L·ªói khi equip pet v·ªõi ID: " .. idpet)
        return false
    end
    task.wait(1) -- TƒÉng th·ªùi gian ch·ªù ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
    return true
end

-- H√†m unequip pet
local function unequipPet(idpet)
    local args = {
        "UnequipPet",
        idpet
    }
    local success = pcall(function()
        RemoteEvent:FireServer(unpack(args))
    end)
    if not success then
        warn("L·ªói khi unequip pet v·ªõi ID: " .. idpet)
        return false
    end
    task.wait(1) -- TƒÉng th·ªùi gian ch·ªù ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
    return true
end

-- H√†m ki·ªÉm tra xem pet c√≥ enchant high-roller kh√¥ng
local function hasHighRoller(pet)
    if pet.Enchants then
        for _, enchant in pairs(pet.Enchants) do
            if enchant.Id == "high-roller" then
                return true
            end
        end
    end
    return false
end

-- H√†m c·∫≠p nh·∫≠t tr·∫°ng th√°i Team 1
local function updateTeam1Status(playerData, currentTeam, petsWithoutHighRoller, highRollerCountInTeam, teamSize)
    if not playerData or not playerData.Teams or not playerData.Teams[1] or not playerData.Pets then
        warn("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu Team 1 ho·∫∑c Pets.")
        return nil, nil, nil, nil, nil
    end

    local team1 = playerData.Teams[1].Pets
    local allPets = playerData.Pets

    currentTeam = {}
    highRollerCountInTeam = 0
    petsWithoutHighRoller = {}
    print("Danh s√°ch pet trong Team 1 (c·∫≠p nh·∫≠t):")
    for _, id in pairs(team1) do
        currentTeam[id] = true
        local pet = nil
        for _, p in pairs(allPets) do
            if p.Id == id then
                pet = p
                break
            end
        end
        if pet then
            local isHighRoller = hasHighRoller(pet)
            print("Pet ID: " .. id .. ", C√≥ high-roller: " .. tostring(isHighRoller))
            if isHighRoller then
                highRollerCountInTeam = highRollerCountInTeam + 1
            else
                table.insert(petsWithoutHighRoller, id)
            end
        else
            warn("Kh√¥ng t√¨m th·∫•y pet v·ªõi ID " .. id .. " trong allPets.")
        end
    end
    teamSize = #team1

    return team1, allPets, currentTeam, highRollerCountInTeam, petsWithoutHighRoller, teamSize
end

-- H√†m qu·∫£n l√Ω pet trong Team 1
local function manageTeam1Pets()
    -- L·∫•y d·ªØ li·ªáu ng∆∞·ªùi ch∆°i t·ª´ LocalDataService
    local playerData = LocalDataService:Get()

    -- Ki·ªÉm tra xem d·ªØ li·ªáu c√≥ t·ªìn t·∫°i kh√¥ng
    if not playerData or not playerData.Teams or not playerData.Teams[1] or not playerData.Pets then
        warn("Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu Team 1 ho·∫∑c Pets t·ª´ LocalDataService.")
        return
    end

    local team1 = playerData.Teams[1].Pets
    local allPets = playerData.Pets

    -- T·∫°o danh s√°ch c√°c pet c√≥ high-roller t·ª´ t·∫•t c·∫£ pet
    local availableHighRollerPets = {}
    for _, pet in pairs(allPets) do
        if hasHighRoller(pet) then
            table.insert(availableHighRollerPets, pet.Id)
        end
    end

    -- In danh s√°ch pet high-roller c√≥ s·∫µn
    print("Danh s√°ch pet high-roller c√≥ s·∫µn: " .. table.concat(availableHighRollerPets, ", "))

    -- Ki·ªÉm tra Team 1 v√† ƒë·∫øm s·ªë pet high-roller ban ƒë·∫ßu
    local currentTeam = {}
    local highRollerCountInTeam = 0
    local petsWithoutHighRoller = {}
    print("Danh s√°ch pet trong Team 1 ban ƒë·∫ßu:")
    for _, id in pairs(team1) do
        currentTeam[id] = true
        local pet = nil
        for _, p in pairs(allPets) do
            if p.Id == id then
                pet = p
                break
            end
        end
        if pet then
            local isHighRoller = hasHighRoller(pet)
            print("Pet ID: " .. id .. ", C√≥ high-roller: " .. tostring(isHighRoller))
            if isHighRoller then
                highRollerCountInTeam = highRollerCountInTeam + 1
            else
                table.insert(petsWithoutHighRoller, id)
            end
        else
            warn("Kh√¥ng t√¨m th·∫•y pet v·ªõi ID " .. id .. " trong allPets.")
        end
    end

    -- So s√°nh s·ªë pet high-roller trong Team 1 v·ªõi s·ªë pet high-roller c√≥ s·∫µn
    local totalHighRollerPets = #availableHighRollerPets
    local teamSize = #team1
    print("S·ªë pet high-roller trong Team 1 ban ƒë·∫ßu: " .. highRollerCountInTeam .. "/" .. totalHighRollerPets .. ", T·ªïng s·ªë pet: " .. teamSize .. "/8")

    -- N·∫øu ch∆∞a s·ª≠ d·ª•ng h·∫øt pet high-roller, t·ªëi ∆∞u h√≥a
    if highRollerCountInTeam < totalHighRollerPets then
        -- T√≠nh s·ªë pet high-roller c·∫ßn th√™m
        local highRollersToAdd = totalHighRollerPets - highRollerCountInTeam
        -- T√≠nh s·ªë slot c√≥ th·ªÉ thay th·∫ø (d·ª±a tr√™n s·ªë pet kh√¥ng c√≥ high-roller ho·∫∑c slot tr·ªëng)
        local slotsAvailable = 8 - teamSize
        local nonHighRollerCount = #petsWithoutHighRoller
        local replacementsPossible = math.min(highRollersToAdd, nonHighRollerCount + slotsAvailable)

        if replacementsPossible > 0 then
            print("Ch∆∞a s·ª≠ d·ª•ng h·∫øt pet high-roller, c·∫ßn th√™m " .. replacementsPossible .. " pet high-roller...")

            -- Unequip c√°c pet kh√¥ng c√≥ high-roller n·∫øu c·∫ßn
            local replacementsNeeded = math.min(nonHighRollerCount, highRollersToAdd)
            for i = 1, replacementsNeeded do
                local id = petsWithoutHighRoller[i]
                if not unequipPet(id) then
                    warn("Kh√¥ng th·ªÉ unequip pet " .. id .. ", b·ªè qua...")
                    return
                end
                currentTeam[id] = nil
                print("Unequipped pet " .. id .. " v√¨ kh√¥ng c√≥ high-roller")
            end

            -- C·∫≠p nh·∫≠t d·ªØ li·ªáu Team 1 sau khi unequip
            task.wait(2) -- ƒê·ª£i ƒë·ªÉ d·ªØ li·ªáu ƒë·ªìng b·ªô
            playerData = LocalDataService:Get()
            team1, allPets, currentTeam, highRollerCountInTeam, petsWithoutHighRoller, teamSize = updateTeam1Status(playerData, currentTeam, petsWithoutHighRoller, highRollerCountInTeam, teamSize)
            if not team1 then return end

            -- Equip th√™m pet high-roller
            local addedCount = 0
            for _, id in pairs(availableHighRollerPets) do
                if not currentTeam[id] and addedCount < replacementsPossible then
                    if equipPet(id) then
                        currentTeam[id] = true
                        addedCount = addedCount + 1
                        print("Equipped pet " .. id .. " v·ªõi high-roller")
                    else
                        warn("Kh√¥ng th·ªÉ equip pet " .. id .. ", b·ªè qua...")
                        return
                    end
                end
                if addedCount >= replacementsPossible then break end
            end

            -- Ki·ªÉm tra l·∫°i Team 1 sau khi thay th·∫ø
            task.wait(2) -- TƒÉng th·ªùi gian ch·ªù ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
            playerData = LocalDataService:Get()
            team1, allPets, currentTeam, highRollerCountInTeam, petsWithoutHighRoller, teamSize = updateTeam1Status(playerData, currentTeam, petsWithoutHighRoller, highRollerCountInTeam, teamSize)
            if not team1 then return end

            print("S·ªë pet high-roller trong Team 1 sau khi thay th·∫ø: " .. highRollerCountInTeam .. "/" .. totalHighRollerPets .. ", T·ªïng s·ªë pet: " .. teamSize .. "/8")

            -- L·∫∑p l·∫°i ƒë·ªÉ t·ªëi ∆∞u h√≥a cho ƒë·∫øn khi s·ª≠ d·ª•ng h·∫øt pet high-roller ho·∫∑c Team 1 ƒë·∫ßy v√† t·ªëi ∆∞u
            local maxIterations = 5 -- Gi·ªõi h·∫°n s·ªë l·∫ßn l·∫∑p ƒë·ªÉ tr√°nh v√≤ng l·∫∑p v√¥ h·∫°n
            local iteration = 0
            while highRollerCountInTeam < totalHighRollerPets and iteration < maxIterations do
                iteration = iteration + 1
                slotsAvailable = 8 - teamSize

                -- Tr∆∞·ªùng h·ª£p 1: C√≤n slot tr·ªëng, b·ªï sung pet high-roller
                if slotsAvailable > 0 then
                    local additionalHighRollersToAdd = totalHighRollerPets - highRollerCountInTeam
                    local additionalSlotsPossible = math.min(additionalHighRollersToAdd, slotsAvailable)

                    if additionalSlotsPossible > 0 then
                        print("C√≤n " .. additionalSlotsPossible .. " slot tr·ªëng, b·ªï sung th√™m pet high-roller (l·∫ßn " .. iteration .. ")...")
                        addedCount = 0
                        for _, id in pairs(availableHighRollerPets) do
                            if not currentTeam[id] and addedCount < additionalSlotsPossible then
                                if equipPet(id) then
                                    currentTeam[id] = true
                                    addedCount = addedCount + 1
                                    print("Equipped additional pet " .. id .. " v·ªõi high-roller")
                                else
                                    warn("Kh√¥ng th·ªÉ equip pet " .. id .. ", b·ªè qua...")
                                    return
                                end
                            end
                            if addedCount >= additionalSlotsPossible then break end
                        end

                        -- Ki·ªÉm tra l·∫°i Team 1 sau khi b·ªï sung
                        task.wait(2) -- TƒÉng th·ªùi gian ch·ªù ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
                        playerData = LocalDataService:Get()
                        team1, allPets, currentTeam, highRollerCountInTeam, petsWithoutHighRoller, teamSize = updateTeam1Status(playerData, currentTeam, petsWithoutHighRoller, highRollerCountInTeam, teamSize)
                        if not team1 then return end
                        print("S·ªë pet high-roller trong Team 1 sau khi b·ªï sung slot tr·ªëng (l·∫ßn " .. iteration .. "): " .. highRollerCountInTeam .. "/" .. totalHighRollerPets .. ", T·ªïng s·ªë pet: " .. teamSize .. "/8")
                    end
                end

                -- Tr∆∞·ªùng h·ª£p 2: C√≤n pet kh√¥ng c√≥ high-roller v√† v·∫´n c√≤n pet high-roller ch∆∞a s·ª≠ d·ª•ng, thay th·∫ø ngay c·∫£ khi c√≤n slot tr·ªëng
                if highRollerCountInTeam < totalHighRollerPets and #petsWithoutHighRoller > 0 then
                    local additionalHighRollersToAdd = totalHighRollerPets - highRollerCountInTeam
                    local additionalReplacementsPossible = math.min(additionalHighRollersToAdd, #petsWithoutHighRoller)

                    if additionalReplacementsPossible > 0 then
                        print("V·∫´n c√≤n " .. additionalReplacementsPossible .. " pet high-roller ch∆∞a s·ª≠ d·ª•ng, thay th·∫ø pet kh√¥ng c√≥ high-roller (l·∫ßn " .. iteration .. ")...")

                        -- Unequip c√°c pet kh√¥ng c√≥ high-roller
                        for i = 1, additionalReplacementsPossible do
                            local id = petsWithoutHighRoller[i]
                            if not unequipPet(id) then
                                warn("Kh√¥ng th·ªÉ unequip pet " .. id .. ", b·ªè qua...")
                                return
                            end
                            currentTeam[id] = nil
                            print("Unequipped pet " .. id .. " v√¨ kh√¥ng c√≥ high-roller")
                        end

                        -- C·∫≠p nh·∫≠t d·ªØ li·ªáu Team 1 sau khi unequip
                        task.wait(2) -- ƒê·ª£i ƒë·ªÉ d·ªØ li·ªáu ƒë·ªìng b·ªô
                        playerData = LocalDataService:Get()
                        team1, allPets, currentTeam, highRollerCountInTeam, petsWithoutHighRoller, teamSize = updateTeam1Status(playerData, currentTeam, petsWithoutHighRoller, highRollerCountInTeam, teamSize)
                        if not team1 then return end

                        -- Equip th√™m pet high-roller
                        addedCount = 0
                        for _, id in pairs(availableHighRollerPets) do
                            if not currentTeam[id] and addedCount < additionalReplacementsPossible then
                                if equipPet(id) then
                                    currentTeam[id] = true
                                    addedCount = addedCount + 1
                                    print("Equipped additional pet " .. id .. " v·ªõi high-roller")
                                else
                                    warn("Kh√¥ng th·ªÉ equip pet " .. id .. ", b·ªè qua...")
                                    return
                                end
                            end
                            if addedCount >= additionalReplacementsPossible then break end
                        end

                        -- Ki·ªÉm tra l·∫°i Team 1 sau khi thay th·∫ø
                        task.wait(2) -- ƒê·ª£i ƒë·ªÉ d·ªØ li·ªáu ƒë·ªìng b·ªô
                        playerData = LocalDataService:Get()
                        team1, allPets, currentTeam, highRollerCountInTeam, petsWithoutHighRoller, teamSize = updateTeam1Status(playerData, currentTeam, petsWithoutHighRoller, highRollerCountInTeam, teamSize)
                        if not team1 then return end
                        print("S·ªë pet high-roller trong Team 1 sau khi thay th·∫ø (l·∫ßn " .. iteration .. "): " .. highRollerCountInTeam .. "/" .. totalHighRollerPets .. ", T·ªïng s·ªë pet: " .. teamSize .. "/8")
                    end
                else
                    break -- Kh√¥ng c√≤n pet ƒë·ªÉ thay th·∫ø ho·∫∑c ƒë√£ s·ª≠ d·ª•ng h·∫øt pet high-roller
                end
            end

            -- In tr·∫°ng th√°i cu·ªëi c√πng c·ªßa Team 1
            print("Tr·∫°ng th√°i cu·ªëi c√πng c·ªßa Team 1:")
            for _, id in pairs(team1) do
                local pet = nil
                for _, p in pairs(allPets) do
                    if p.Id == id then
                        pet = p
                        break
                    end
                end
                if pet then
                    local isHighRoller = hasHighRoller(pet)
                    print("Pet ID: " .. id .. ", C√≥ high-roller: " .. tostring(isHighRoller))
                else
                    warn("Kh√¥ng t√¨m th·∫•y pet v·ªõi ID " .. id .. " trong allPets.")
                end
            end
            print("S·ªë pet high-roller trong Team 1 cu·ªëi c√πng: " .. highRollerCountInTeam .. "/" .. totalHighRollerPets .. ", T·ªïng s·ªë pet: " .. teamSize .. "/8")
        else
            print("Kh√¥ng c√≥ pet kh√¥ng c√≥ high-roller ƒë·ªÉ thay th·∫ø ho·∫∑c kh√¥ng c√≥ slot tr·ªëng.")
        end
    else
        print("ƒê√£ s·ª≠ d·ª•ng h·∫øt pet high-roller c√≥ s·∫µn ho·∫∑c Team 1 ƒë√£ t·ªëi ∆∞u.")
    end
end

-- H√†m t·ª± ƒë·ªông qu·∫£n l√Ω Team 1 m·ªói 5 ph√∫t
local function autoManageTeam1Pets()
        equipbestpet()
        task.wait(1)
    while true do    
        print("Ki·ªÉm tra v√† qu·∫£n l√Ω pet trong Team 1...")
        local success, err = pcall(manageTeam1Pets)
        if not success then
            warn("L·ªói khi qu·∫£n l√Ω Team 1 Pets: " .. tostring(err))
        end
        task.wait(300) -- Ch·ªù 5 ph√∫t (300 gi√¢y) tr∆∞·ªõc khi ki·ªÉm tra l·∫°i
    end
end

-- H√†m ki·ªÉm tra gi√° tr·ªã buffluck
local function checkBuffLuck()
    local success, buffluck = pcall(function()
    return game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.SummerEventBoard.Frame.Main.ActiveEvents.Container.List.Template.Frame.Title.Event.Text
    end)

    local ignoredBuffs = {
        "üçÄ Double Luck üçÄ",
        "üöÄ Fast Hatch üöÄ",
        "ü•ö Extra Hatch ü•ö",
    }
    
    -- Ki·ªÉm tra n·∫øu buffluck kh√¥ng n·∫±m trong danh s√°ch b·ªè qua
    for _, buff in ipairs(ignoredBuffs) do
        if buffluck == buff then
            return -- Tho√°t n·∫øu buffluck l√† m·ªôt trong c√°c gi√° tr·ªã b·ªè qua
        end
    end

    -- N·∫øu buffluck kh√¥ng n·∫±m trong danh s√°ch b·ªè qua, b·∫Øt ƒë·∫ßu ki·ªÉm tra ƒë·ªãnh k·ª≥
    while true do
        local newSuccess, newBuffluck = pcall(function()
            return game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.SummerEventBoard.Frame.Main.ActiveEvents.Container.List.Template.Frame.Title.Event.Text
        end)

        if newSuccess then
            for _, buff in ipairs(ignoredBuffs) do
                if newBuffluck == buff then
                    task.wait(math.random(1, 600))
                    rejoinServer()
                    break
                end
            end

        else
            print("L·ªói khi l·∫•y gi√° tr·ªã buffluck")
        end
        task.wait(math.random(30, 180)) -- Ch·ªù 30 gi√¢y tr∆∞·ªõc khi ki·ªÉm tra l·∫°i
    end
end




-- B·∫Øt ƒë·∫ßu c√°c lu·ªìng song song
-- task.spawn(equipbestpet)
task.spawn(autoUpgradePetsAndBuffs)
task.spawn(autoUpgradeShops)
task.spawn(autoUpgradeMinigames)
task.spawn(checkCurrencies)
-- task.spawn(autoManageTeam1Pets) -- Th√™m lu·ªìng qu·∫£n l√Ω Team 1
task.spawn(autoCraftPotions)
-- task.spawn(autoUsePotions)
-- task.spawn(checkDiceAndRoll)
task.spawn(checkBuffLuck)

-- √Åp d·ª•ng c√°c c√†i ƒë·∫∑t game
setSetting("Low Detail Mode", true)
setSetting("Hide All Pets", true)
setSetting("Hide Others Pets", true)
setSetting("Hide Bubbles", true)
setSetting("kip Easy Legendary", true)
setSetting("Compact Pet Inventory", true)
setSetting("Hide Global Secret Messages", true)
setSetting("Sound Effects", 0)
setSetting("Music", 0)
setSetting("Bubble Gravity", 0)
